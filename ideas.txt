condition {
	fn, parama, paramb
}

if_instruction 
	vector<condition>
	vector<ctx_index>
	else_index = 0

IT FOLLOWS THAT:

	we have an interpreter that runs N scripts
		and has the pointer of the currently executing command, or the next one
		when an script ends / returns, it is removed from the queue
		it would be great if it could be interrupted from the outside... but I don't
			see how, actually.
	we have a host entity that receives the sends, evaluates ifs, etc.

== PARSER ======================================================================

1 -> a number
1.2 -> a number??
true / false -> a boolean
"hello" -> a string, no scaping so far
[ open bracket
] close bracket
; command end.

RESERVED WORDS:
if, is_equal, is_not_equal, is_greater_than, is_lesser_than, elseif, else, 
endif, loop, break, endloop, yield, return, let, be, int, string, bool, as,
host_has, host_add, host_get, host_set, host_query, host_do, beginscript, 
endscript, call

ANYTHING ELSE:
an identifier that should exist in the current symbol table.

== CONDITIONALS ================================================================

if VERB [params];
	is_equal
	is_greater_than
	is_lesser_than
elseif VERB [params];

else;

endif;

== CALLING =====================================================================

call [scriptname] (scripts take no params, at least now)

== LOOP ========================================================================

loop
break
endloop

== EXITING =====================================================================

yield
return
fail [message]

== VARIABLES ===================================================================

let IDENTIFIER be TYPE AS expression;
	identifiers are declared in the current scope, scopes are script, ifblock
	and loopblock.

== HOST ========================================================================

#interacting with the host
## asks if a value exists in host symbol table
host_has [name, value]

## adds value in host symbol table
host_add [name, type, value]

## sets value in host symbol table
host_set [name, value]

## gets value from host symbol table
host_get [name]

## makes the host run a host-dependant command, then return a value
host_query [type, comma, separated, list] -> returns a value

## makes the host execute something host-dependant.
host_do [comma, separated, list] -> makes the host do something

--------------------------------------------------------------------------------

beginscript raise_and_lower_platform

	#do not run if n times have passed, whatever.
	let check be bool as host_has ["playtime"];
	if is_equal [check, false];
		fail ["playtime should be defined"];
	endif

	let time be int as host_get [int, "playtime"];
	if is_greater_than [time, 3600] then;
		return;
	endif;

	#do not run if the button is active
	let platform_active be bool as host_query [bool, "is_active", "platbutton"]
	if is_equal [ platform_active, true ];
		return;
	endif;

	#activate and disable the button
	host_do ["activate", "platbutton"];
	host_do ["disable", "platbutton"];

	#raise platform wait for it to end.
	#TODO: should this be time or absolute space? if it is time, 
	#we can have sync problems.
	host_do ["motion", "platform", 0, 24, 0, 48];
	loop;
		let platform_motionless be bool as host_query [bool, "is_motionless", "platform"];
		if is_equal [platform_motionless, true];
			break;
		endif;
		yield;
	endloop;

	#lower platform, wait for it to end
	host_do ["motion", "platform", 0, -24, 0, -48];
	loop;
		let platform_motionless be bool as host_query [bool, "is_motionless", "platform"];
		if is_equal [platform_motionless, true];
			break;
		endif;
		yield;
	endloop;

	#enable button
	host_do ["enable", "platbutton"];

endscript
IT FOLLOWS THAT:

	we have an interpreter that runs N scripts
		and has the pointer of the currently executing command, or the next one
		when an script ends / returns, it is removed from the queue
		it would be great if it could be interrupted from the outside... but I don't
			see how, actually.
	we have a host entity that receives the sends, evaluates ifs, etc.

== PARSER ======================================================================

1 -> a number
1.2 -> a number??
true / false -> a boolean
"hello" -> a string, no scaping so far
[ open bracket
] close bracket
; command end.

RESERVED WORDS:
if, is_equal, is_not_equal, is_greater_than, is_lesser_than, elseif, else, 
endif, loop, break, endloop, yield, return, let, be, int, string, bool, as,
host_has, host_add, host_get, host_set, host_query, host_do, beginscript, 
endscript, call

ANYTHING ELSE:
an identifier that should exist in the current symbol table.

== CONDITIONALS ================================================================

if VERB [params];
	is_equal
	is_not_equal
	is_greater_than
	is_lesser_than
elseif VERB [params];

else;

endif;

== CALLING =====================================================================

call [scriptname] (scripts take no params, at least now)

== LOOP ========================================================================

loop
break
endloop

== EXITING =====================================================================

yield
return
fail [message]

== VARIABLES ===================================================================

let IDENTIFIER be TYPE AS expression;
	identifiers are declared in the current scope, scopes are script, ifblock
	and loopblock.

== HOST ========================================================================

#interacting with the host
## asks if a value exists in host symbol table
host_has [name, value]

## adds value in host symbol table
host_add [name, type, value]

## sets value in host symbol table
host_set [name, value]

## gets value from host symbol table
host_get [name]

## makes the host run a host-dependant command, then return a value
host_query [type, comma, separated, list] -> returns a value

## makes the host execute something host-dependant.
host_do [comma, separated, list] -> makes the host do something

--------------------------------------------------------------------------------

beginscript raise_and_lower_platform

	#do not run if n times have passed, whatever.
	let check be bool as host_has ["playtime"];
	if is_equal [check, false];
		fail ["playtime should be defined"];
	endif

	let time be int as host_get [int, "playtime"];
	if is_greater_than [time, 3600] then;
		return;
	endif;

	#do not run if the button is active
	let platform_active be bool as host_query [bool, "is_active", "platbutton"]
	if is_equal [ platform_active, true ];
		return;
	endif;

	#activate and disable the button
	host_do ["activate", "platbutton"];
	host_do ["disable", "platbutton"];

	#raise platform wait for it to end.
	#TODO: should this be time or absolute space? if it is time, 
	#we can have sync problems.
	host_do ["motion", "platform", 0, 24, 0, 48];
	loop;
		let platform_motionless be bool as host_query [bool, "is_motionless", "platform"];
		if is_equal [platform_motionless, true];
			break;
		endif;
		yield;
	endloop;

	#lower platform, wait for it to end
	host_do ["motion", "platform", 0, -24, 0, -48];
	loop;
		let platform_motionless be bool as host_query [bool, "is_motionless", "platform"];
		if is_equal [platform_motionless, true];
			break;
		endif;
		yield;
	endloop;

	#enable button
	host_do ["enable", "platbutton"];

endscript

